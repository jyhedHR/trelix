[
    {
        "course_title": "Learn Python Basics for Data Analysis",
        "course_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis",
        "parts": [
            {
                "part_title": "Set up Your Python Work Environment",
                "chapters": [
                    {
                        "chapter_title": "Install Python and Anaconda",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7978748-install-python-and-anaconda",
                        "chapter_content": "Install Python and Anaconda\nHello and welcome! My name is Llewelyn Fernandes. I'm a computer scientist with a focus on teaching about creative computing and data. It’s my pleasure to lead you through this course! Want to know more about what I do? Follow me @tcreatelearn on Instagram or Twitter.\nGet the Most out of This Course\nIn this course, you will see all the basics of the Python language needed before you can start working with and analyzing data.\nThis course will include several coding activities that will let you test the various concepts learned. For this you will need to set up your environment as detailed below.\nDiscover Python\nPython is a general-purpose programming language, meaning that you can code just about anything in it: websites and applications, mobile apps, personal scripts, desktop applications, data analysis, and even video games!\nFor example:\nInstagram is coded in Python.\nIt is one of the main languages used by Google engineers.\nNetflix uses Python to build its recommendation algorithms.\nThe Dropbox desktop application is developed in Python.\nReddit is coded in Python.\nWhen it comes to data, Python is the most widely used language, especially for data processing and manipulation, data visualization, and artificial intelligence algorithm development.\nThere are various distributions of Python that you can use to get going. Below, we introduce you to two options: Google Colab and Anaconda.  Google Colab is the easiest option to start with as it does not require you to install anything on your computer.\nUse Python in the Cloud via Google Colaboratory (Colab)\nIf you don't want the trouble of installing software on your computer, you can use Python in the Cloud, via Google Colaboratory. This is a product from Google Research allowing anyone to write and execute Python code within a Jupyter Notebook, through a web browser (Chrome, Safari, Firefox, etc.). This is what we will use throughout this course to let you practice!\nNo installation is required, you can access it from any machine (as long as it has an internet connection) because all files are stored and run on Google's servers. You need to have a Google account, so set one up if you don’t have one. Then you just have to go to the main Colab page, create a new notebook and... TADAAAA!!! \nYou have launched your first Jupyter Notebook and are ready to continue learning more about this tool in the next chapter.\nInstall Python via Anaconda\nAs an alternative to Colab you can install Anaconda, to give you total control of your development environment on your own computer. Anaconda is a scientific distribution of Python, meaning that when you install Anaconda, you will install Python, Jupyter Notebook (which we will present in more detail in the next chapter), and dozens of scientific packages, some of which are essential for data analysis!\nTo start, download the Anaconda distribution corresponding to your operating system from here: Anaconda distribution page.\nInstall Anaconda on Windows or Mac\nDownload the Windows or macOS installer and double-click to start the installation.\nAnswer the different questions (the default options are enough!). Once the installation is complete, you can check that it went well by launching the Jupyter Notebook application.\nInstall Anaconda on Linux\nDownload the installer for Linux.\nEnter the following statement in the terminal, replacing ANACONDAINSTALLER with the name of the file downloaded:\nbash ~/Downloads/ANACONDAINSTALLER.sh\nThe installer will print: “In order to continue the installation process, please review the license agreement.” Click to see the license agreement, stroll to the bottom and click  yes  to accept.\nAnswer \"yes\" if you see the following question:\nDo you wish the installer to prepend the Anaconda3 install location\nto PATH in your /home/ec2-user/.bashrc ? [yes|no]\nAnswer “yes” if you see the following question:\nDo you want the installer to initialize Anaconda3 by running conda init? [yes|no]\nThe previous commands added the path (the folder) to the .bashrc file where Anaconda is located. So, you will be able to launch Anaconda directly by just typing \"anaconda\" in your console! This operation will take effect when your computer restarts, or as soon as you run this command:\nsource .bashrc\nCheck that everything went well by running the Jupyter program (see below).\nLaunch Jupyter\nOn macOS, launch Anaconda Navigator via Launchpad.\nOn Linux, open a console and run:  anaconda-navigator.\nOn Windows, launch Anaconda Navigator from your Start menu.\nOnce this is done, you will have several applications at your disposal. You are interested in the one called Jupyter Notebook:\nClick on the Launch button and a new tab will appear in your browser session:\nNow that you have Anaconda and Python installed, you'll be introduced to one of the most widely used programming tools in data analysis. Easy to use, practical, and powerful, you will soon get to grips with Jupyter Notebook."
                    },
                    {
                        "chapter_title": "Take Your First Steps with Jupyter Notebook",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7978803-take-your-first-steps-with-jupyter-notebook",
                        "chapter_content": "Take Your First Steps with Jupyter Notebook\nJupyter Notebook is a web application that lets you store lines of Python code, their output (graphs, tables, etc.) and formatted text. This can be compared to a web page containing Python code! A bit like this course, really.\nThere are of course other ways and applications to work with than Python, but we are going to explain why Python is particularly well suited for data analysis and why we recommend it!\nDiscover Jupyter Notebook\nJupyter Notebook is a powerful tool that allows Python language users to create and share interactive documents containing dynamic, runnable code, content displays, documentation text, and equations. The term \"notebook\" is related to the intrinsic nature of the tool, which lets you write small pieces of runnable code (called \"cells\"), document them to explain what they do, and print the resulting output data. All this is stored in a document that can be shared with other users.\nSo it is particularly useful for prototyping algorithms or testing pieces of code to analyze the results and possibly add them to your main project. With a notebook, you don't need to organize your code into functions, with a main, etc. You just need to write your code in the code cells and run it!\nJupyter Notebook for Data Analysis\nJupyter Notebook is a very popular application for everyone who works in data analysis. It lets a team create and share reports in document/code format, facilitating productivity and collaboration.\nFor example, Netflix data scientists work with their data via Jupyter Notebook—their movie recommendation algorithm is coded from Jupyter! You can check out this article on Medium that talks about it in detail.\nTake Your First Steps with Jupyter\nNow that you've launched Jupyter (either locally or via Google Colab) and we've learned a little more about its usefulness, it's time to run our first Python code.\nThroughout this course, you will find links to Google Colab so you can practice along at the same time. You can either use them to perform the different exercises in Colab, or download the Jupyter notebook as a .ipynb file and use your own local Jupyter to test the code shown to you.\nFrom Colab create a new notebook by selecting “New notebook” from the File menu:\nYou should see the notebook appear:\nIf you are using Anaconda, create a new notebook by clicking on New then   Python 3  :\nThis will open a new tab:\nWhether you are using Colab or Anaconda, you will have a new code cell. In Colab, it looks like this:\nIn Anaconda, it looks like this:\nTry writing your first line of code in this cell. Saying “Hello,” for example, would be a good start.\nprint('Hello, world!')\nand then click on  Run.\n in Colab\n in Anaconda\n\"Hello, world!\" should appear below your cell—this is the result of running it. Congratulations, you just ran your very first Python code!\nDid you know that printing “Hello, world!” is usually the first thing you learn when learning any programming language?\nDocument Your Notebook\nBefore you really dive into the programming, you should know that there are different types of cells with Jupyter, the main ones being code and markdown (also called text).\nIn Anaconda, when you click on a cell, you can change the type simply by selecting it from the list, as in the example below:\nLet's look at the two main types in more detail:\nCode—the standard code cell. This one is reserved for writing and running Python code! You can run your code by clicking on the Run button, as seen previously.\nMarkdown—a text cell that is mainly used for notebook documentation, to write comments, titles, equations, etc. This type lets you structure your text using HTML tags or Markdown syntax.\nIn Colab, you can select the cell type by creating a new cell:\nWhether it's markdown or code, just write your text/code and run it via the   Run  button to see the result.\nFor example, we could create a title. To do this, simply add a   #  in front of your text. A single   #  will correspond to a level one title, two   ##  to a level two title, etc.\nYou can also choose to make your text bold or italic. To do this, simply put the following symbols before and after the desired text:\nUse  **  to make it bold.\nUse just   *  to italicize it.\nFor example, the following Markdown cell:\n# A level 1 title \nHere is some text to introduce a markdown \n## level 2 title \n**This** is very important \n## other level 2 title \nBut *this is* as well!\nwill give the following result:\nIf you want to go further into the features of Markdown cells, I advise you to follow this link. \nNow that your Python environment is set up, you are ready to get down to business!"
                    }
                ]
            },
            {
                "part_title": "Handle Fundamental Functions and Objects",
                "chapters": [
                    {
                        "chapter_title": "Declare a Variable",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7978962-declare-a-variable",
                        "chapter_content": "Declare a Variable\nYou know how to print text on the screen. Great! This is a start, but you will be able to do much more after you have seen what variables are in programming.\nUnderstand What a Variable is\nVariables are one of the concepts found in all programming languages. You might as well say that without a variable, you can't program, and that's not an exaggeration.\nAs mentioned in the video, think of a variable as a kind of box containing a value. This box is itself stored on a shelf among many others, in a gigantic warehouse. The location of each box is very precisely recorded, just as your computer records the exact location of your variable in its memory.\nBoxes stored in a warehouse\nA value is what you will store in a variable. To return to the warehouse analogy, there are several boxes for storing different values. For example, if you work in a bank, you might want to store information about a customer in different boxes, such as their checking account balance and their savings account balance. We will also need to perform different operations on these boxes like emptying them, adding money, transferring the contents from one to another, etc. Variables will let you do this!\nTo get to the contents of each box, you will need to label them. The process is similar in programming: each variable is given a name.\nLabeled jars containing your savings\nIn the same way as with box labeling, the name of a variable must always represent its contents. Here are some general recommendations for choosing names for your variables:\nUse clear variable names\nIt sounds tedious to do, but it is really beneficial for you and the people you will share your code with—it makes it easier to read and maintain your code. For example,  savingsAccount  and   checkingAccount   are much more explicit names than   account1  and   account2 .\nUse explicit variable names\nAvoid abbreviations and acronyms, if possible, even if an abbreviation may seem obvious. For example,   annualIncome  is better than   annualInc .\nFollow a typographic convention\nOne of the most common typographic conventions is called camel case (also known as camel caps). It involves writing variable names containing several words without spaces or punctuation—the first word is written in lowercase, then each word is written with the first letter in upper case, as shown above.\nCreate a Variable\nBefore you can use it, you have to create your variable! You just have to associate a value with a name to create a variable; Python takes care of creating the right size ‘box’. Convenient, isn't it?\nThere are several types of variables in Python, much like in the physical world: text, numeric values, arrays, etc. Numeric variables are declared by associating a name with a numeric value. For example:\ncheckingAccount = 500\nsavingsAccount = 1000\nYou have declared two variables here,  checkingAccount  and   savingsAccount , by storing the values 500 and 1,000, respectively.\nYou have only used integers here! But it is quite possible to store decimal numbers.\nIf you store a new value in an existing variable, the type of the variable will change according to the new value. \nUnderstand Operations Between Variables\nAs the name suggests, a variable can vary, or rather the value of a variable can change. You can do this through different operations. Considering the two variables previously declared in the last example, you could:\nadd some money to your savings account.\nwithdraw some from your checking account.\ncalculate how long it would take you to reach $5,000 if you save $500 every month.\ncalculate how much would be in your checking account if you added $30 every day for a week.\ncalculate how much would be in your checking account if you spent $10 every day.\netc.\nIn short, these are concrete problems that can be solved with Python. Each operation will use arithmetic operators:\n+ : addition\n- : subtraction\n* : multiplication\n/ : division\nThe rules of arithmetic apply in Python, in particular the order of operations, but as in ordinary mathematics, you can use brackets to rearrange the order of the calculations. See how to do this in Python:\n# add 100 to our savings (Yeah!)\nsavingsAccount = savingsAccount + 100\n# remove 50 from our checkingaccount (Sniff)\ncheckingAccount = checkingAccount - 50\n# calculate the number of days to save to reach 5000\nnumberDaysSave = (5000 - checkingAccount) / 500\n# update our checkingaccount (again) after the daily gains/losses\ncheckingAccount = checkingAccount + (30 - 10) * 7\nThat makes a nice piece of code, doesn't it? If you pay attention, you will notice that there are different colors in different places. This is because your code is made up of comments and expressions:\nLines starting with a # are comments. They are used to document your code and help others understand it.\nThe other lines of code (which can run operations, declarations, etc.) are expressions. They tell the computer what to do.\nHere, each of the expressions assigns a value to a variable. The assignment operator is   = .\nTo the right of the assignment operator is the expression that will create/calculate a value.\nTo the left of the assignment operator, you write the name of the variable to which you will assign the corresponding value.\nTo summarize, to assign a value to a variable, you write an expression. This expression is built with the name of the variable, followed by the assignment operator = and finally the value to associate.\nThere are also other arithmetic operators that are a little more complex, but nevertheless useful, such as:\n% modulo : returns the remainder of the euclidean division\n** power : raises a number to a certain power\n// integer division: calculates the integer division (rounded down)\nprint(SavingsAccount % 500) # -> 100\n# 1100 = 500 * 2 + 100, so 1100 % 500 = remainder = 100\nprint(9 ** 3) # -> 729, 9*9*9 = 729\nprint(SavingsAccount // 500) # -> 2\n# 1100 = 500 * 2 + 100, so 1100 // 500 = integer division result = 2*\nTry it for Yourself\nTry to declare a variable from two other variables in the following exercise yourself.\nYou can find the solution right here.\nWrite Shorter Code with Simplified Operators\nWhen you want to change a variable by changing the initial value via a basic operator, you can use a shorter version. In other words, you can use simplified operators! For example, rather than using the expression  savingsAccount = savingsAccount + 100  to add $100 to your variable, you can use a kind of combined arithmetic/assignment operator   += :\n# long version\nsavingsAccount = savingsAccount + 100\n# equivalent short version\nsavingsAccount += 100\nNaturally, there is a version for each arithmetic operator seen previously:\n-=  for subtraction\n*=  for multiplication\n/=  for division\n%=  for the remainder of the integer division\netc.\nTry it for Yourself\nTry to use these simplified operators by yourself in the following exercise.\nYou can find the corrected version right here.\nGo Beyond Arithmetic\nIn the example above, all variables are used to store numerical amounts of money (integer or decimal).\nAre there other types of variables other than numeric ones?\nOf course! In fact, it is possible to store any type of data in a variable.\nSo far, you have seen that a variable is made up of a name and a value that will automatically define its type. Yet, to return to your warehouse analogy, one can imagine that storing money, storing a book, or storing a car require different size boxes, or even containers. In Python, the storage space of a variable automatically adapts to its contents, almost by magic!\nAt this point, it is safe to assume that having only the ‘amount’ value stored in each of your customer's accounts will probably not be enough. We will most likely also need their name, their interest rate expressed as a percentage, their address, etc., with a new variable for each of these pieces of information. So we would need to store text in our variables.\nYou could declare these three variables as follows:\nfirstName = \"Benjamin\"\ninterestRate = 1.5\naddress = \"15 19 Bloomsbury Way, Holborn, London, WC1A 2TH\"\nNote that you need to use double quotes (\") to define strings—textual variables—in Python, otherwise you will get an error! You can however use single (') or double quotes to declare text variables as seen below:\naddress = '15 19 Bloomsbury Way, Holborn, London, WC1A 2TH'\n# equivalent to\naddress = \"15 19 Bloomsbury Way, Holborn, London, WC1A 2TH\"\nYou will go into more detail about the different types of variables in Python in the next chapters, but for now you have seen three different types of variables:\nInteger variables (int)\nDecimal variables (float)\nCharacter strings (string)\nLet's Recap\nIn this chapter, you have learned the basics about variables:\nA variable is made up of two parts: its name and its value.\nAssigning a value to a variable is called an assignment.\nThe value of a variable can be changed.\nThe type of a variable depends on its value.\nThe names of your variables should be clear, explicit, and should follow a typographic convention.\nIn the next chapter, you will learn more about variable types!"
                    },
                    {
                        "chapter_title": "Handle Variable Types",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979063-handle-variable-types",
                        "chapter_content": "Handle Variable Types\nUnderstand Why We Need Variable Types\nYou looked at different types of variables in the previous chapter, but there is much more to know about the subject!\nThe types encountered so far are called primitive types. They exist in Python—a bit like atoms. These are the simplest types of variables; they are the foundation of all computer operations and programs. In the same way that atoms can be combined to make more complex molecules, you can combine primitive types to create much more complex variable types, as you will see in the next parts of this course. For now, you will explore numeric types and strings in a little more depth. Let's go!\nNumeric Variables\nNumeric variables can be broken down into two distinct types:\nIntegers, which correspond to the set of positive or negative integers (1, 2, 0, 123, -3, etc.)\nDecimals, which, in addition to integers, include all decimal numbers (2.50, 5.99, -1.20, etc.)\nStart with the one you are already familiar with: integers. Integers are declared like any other variable, by associating a value to a variable name.\naccount = 10\nHere you have the value 10 associated with the variable account. 10 being an integer,  accountis automatically an integer variable (int).\nFor decimal numbers ,  python uses the float type. You can define it in the same way as integers, by simply adding the decimal point explicitly:\nlength = 1876.79\nwidth = 870.0\nAs long as the associated value is a decimal number, Python will automatically consider the variable as beingfloat. This is true even if the digit after the decimal point is a 0, as is the case above with the width variable.\nMix Several Numeric Variables\nIt is important to keep in mind how the different numeric types can be mixed together and what the potential consequences are. If you mix different types, the most complex will be the one kept for the final result. For example, an integer value can be stored as a float, as seen above with the width variable, but the opposite is not possible if there are numbers after the decimal point! The  float  is therefore the most complex type: if you mix an   int  with a   float ,  the result will always be a   float , whatever operation is performed or whatever the result is.\na = 7.5\nb = 3\nc = a/b\nprint(c)\n# this will print 2.5, which is a float\nIf the result of an operation between two integers is supposed to be a decimal number, Python will automatically convert it to a float. Moreover, division (even if the result is supposed to be an integer) will necessarily return a float as well:\na = 10\nb = 5\nc = a/b\nprint(c)\n# it's a float\nHowever, you can force the conversion of a variable into a well-defined type. This is called typecasting, because by doing so you are changing (casting) the type of a variable. To do this, you will need the corresponding functions:\nint() : for integers\nfloat() : for decimals\na = 14.0\n# a is a float\na = int(a)\nprint(a)\n# a is now an integer: it prints 14 and not 14.0\nTry it for Yourself\nTry to transform the type of our variable in the following exercise.\nYou can find the solution right here.\nCharacter Strings\nYou will now explore a little more about character strings, which let you store text in your variables. First, a bit of semantics: we call them character strings, because Python does not consider these variables as text, as such, but as a set of characters put together. This is how you can define character strings in Python (you can use either single or double quotes):\ncity = 'New York'\nfilm = 'taxi driver'\nemptyString = ''\ncity = 'New York'\nfilm = 'taxi driver'\nemptyString = ''\nCharacter strings are   string  types in Python.\nAssembling several   strings  together is one of the most common operations you will have to perform when using   strings—his operation is called concatenation. See how to do this in Python:\nfavoriteCityOne = \"San Francisco\"\nfavoriteCityTwo = \"New York\"\nfavorites = favoriteCityOne + favoriteCityTwo\nprint(favorites) # => \"San FranciscoNew York\"\nNote that there is no space between the two. Make your code more readable by concatenating your variables with other strings:\nfavoriteCityOne = \"San Francisco\"\nfavoriteCityTwo = \"New York\"\nfavorites = \"My favorite cities are \" + favoriteCityOne + \" and \"+ favoriteCityTwo\nprint(favorites) # -> \"My favorite cities are San Francisco and New York\"\nIt's much better this way, isn't it? However, you cannot concatenate other types of variables with strings, such as numeric variables---this would return an error. To remedy this, you will need to cast your numeric variable to a string, via the  str()  function:\ncity = \"Sydney\"\nnumberTrips = 5\nhistory = \"I've been to \" + city + \" \" + str(numberTrips) + \" times \"\nprint(history) # => \"I've been to Sydney 5 times\"\nYou have seen that the operator   +  can have different purposes depending on the types of variables you work with:\nWith numeric types, it is used to add.\nWith strings, it is used to concatenate.\nLet's Recap\nIn this chapter, you have encountered three primitive types of variables, essential to all programs/analyses:\nIntegers (int)\nDecimals (float)\nCharacter strings (string)\nYou have also seen how to use these different types:\nYou can perform numeric operations on numeric variables of different types.\nYou can cast variables to force the transformation of the type of a variable into another specific type, according to your needs.\nStrings can be assembled together: this is called concatenation.\nIn the next chapter you will see how to write and use functions. Let's go!"
                    },
                    {
                        "chapter_title": "Write Your Own Functions",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979178-write-your-own-functions",
                        "chapter_content": "Write Your Own Functions\nSince the beginning of this course, you have used different functions, such as the   print()  function of the different cast functions like  int()  or  str()  . We will now take the time to define what a function is, what it is used for and how you can create your own functions—you are going to find out everything there is to know about functions!\nDiscover Functions\nDuring your data analysis, you will regularly have to use groups of statements several times for a very specific purpose. One of the fundamental principles for any computer programmer is to get maximum results for minimum effort (there is even a saying that a good programmer is a lazy programmer!). It is thanks to this somewhat \"lazy\" but very effective principle that the idea of functions came about. Functions can group several statements in a block which will be called using a name.\nFunctions are not specific to Python; they are present in all computer languages. They can:\nreuse a portion of code already written just by stating the function name—so you don't have to rewrite the whole portion of code each time.\nsimplify code and make it more readable!\nThere are many pre-existing functions in Python! In addition to those already seen, there are, for example:\nlen() :  a function that returns the length of an item. Do you remember strings? Using this function on a string tells you how many characters the string contains.\ntype() : lets you print the type of a variable.\npow(a, b) : lets you calculate a to the power of b. It is equivalent to writing a**b.\nabs() :  returns the absolute value of a number.\nHere are some examples to illustrate the use of these functions:\nBasic Functions in Python\nWrite Your Own Functions\nNow suppose you are asked to develop a program involving geometry. You have to use a lot of triangles for which you have the length of the three sides, and you want to print their perimeter. You could, of course, do this for each triangle by hand, but remember: you want maximum results for the least amount of effort. So, you are going to create a function that will print the perimeter of a triangle according to the length of its sides!\nA function is defined via the keyword   def  followed by the name of the function. All the statements associated with this function will then be written after the colon.\ndef functionName():\n    # statements\n    # that can go\n    # on several\n    # lines\nNote that all the statements associated with your function are offset in the code: this is called indentation. Python is a block structured language: each group or block of program must be indented. For example, the set of indented statements following the : will only be available in   functionName . Indentation starts the block, and \"de-indentation\" ends it (the first non-indented line will therefore no longer be included in   functionName ).\nIndentation is a fundamental principle in Python, which you will encounter many times in the future. Generally, it translates into four spaces or a tab.\nNow define a function that would answer your problem:\ndef printPerimeter():\n    dimension1 = 6\n    dimension2 = 4\n    dimension3 = 3\n    perimeter = dimension1 + dimension2 + dimension3\n    print(perimeter)\nprintPerimeter() # => 13\nThis function is correct, but not entirely useful: not all of your triangles will have the exact same dimensions.\nDefine the Parameters\nTo overcome this limitation, you must make your function accept external numbers. You can do this by defining parameters.\nIn Python, parameters, just like the name of the function, are defined when the function is written. This is how it would look with the above example:\ndef printPerimeter(dimension1, dimension2, dimension3):\n    perimeter = dimension1 + dimension2 + dimension3\n    print(perimeter)\nParameters are variables defined during the declaration of the function, specified inside brackets. Now you can use your function with any existing triangle:\nprintPerimeter(10, 11, 4) # => 25\nprintPerimeter(2, 2, 3.5) # => 7.5\nEach value is assigned to a parameter, in the order in which they were defined. For example, in the first test:\nthe variable   dimension1  will have a value of 10.\nthe variable   dimension2  will have a value of 11.\nthe variable   dimension3  will have a value of 4.\nThe function will then perform all the operations specified in the body of the function (i.e., the indented lines) with these values.\nParameters are variables declared in a function. The values that are passed as parameters are called arguments.\nSo, that's great, you've added some features to your function!\nNow, what can I do with the result?\nOften, when you use a function in a code, you expect an answer that you can reuse to move forward in the code. This answer can be provided via the value returned by a function.\nDefine a Return Value\nTo define a return value, you must explicitly use the return keyword at the end of your function.\nYou could change your   printPerimeter  function into   calculatePerimeter  which will return the perimeter of a triangle, according to the length of its three sides, so that it can be reused afterwards:\ndef calculatePerimeter(dimension1, dimension2, dimension3):\n    perimeter = dimension1 + dimension2 + dimension3\n    return perimeter\nOnce you have defined your function, you can use it as many times as necessary:\nperimeter1 = calculatePerimeter(6, 4, 3)\nperimeter2 = calculatePerimeter(10, 3, 11)\nprint(\"The perimeter of my first triangle is\", perimeter1, \"and that of my second is\", perimeter2)\nAnd if you analyze these lines, you will realize that every time you use the   print  function, you send the items to be printed as parameters.\nNote that you can pass several arguments to the   print  function and the result will be the concatenation of all arguments. By doing so, you don't need to cast the numeric variables to strings, as the print function will do that for you!\nUse the Help Function if You Forget\nIn your experience in data analysis, you will often remember the name of a function, but not necessarily what it does or its arguments, etc. Don't panic! The   help  function is there for that! If you run   help(functionName) , this will print the documentation of this function, summarizing:\nits purpose.\nrecommendations for use.\nthe list and description of the parameters.\nsometimes even examples.\nHere is an example with the power function (pow) seen above:\nHelp Documentation for the Pow Function\nPhew, you've learned a lot in very little time. What progress!\nLet's Recap\nIn this chapter, you have seen that:\nfunctions can have parameters and return values.\na return value is the result of running the function. The return value is returned to the code that called the function, to be used as needed.\nthe parameters are the data necessary for a function to be run and generate a result.\nparameters are variables defined by a name. Parameters are specified in the function declaration.\nwhen using a function, you pass it different values as parameters. These values are called arguments.\nyou can use the help function to print the documentation of a given function.\nIn the next chapter, you will discuss the concept of object-oriented programming and what it means for you in Python."
                    },
                    {
                        "chapter_title": "Object-Oriented Programming",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979247-object-oriented-programming",
                        "chapter_content": "Object-Oriented Programming\nPython is an object-oriented programming language—this means that in Python, everything is an object! In this chapter, you will see what this means and how you can use it in a practical way. Start by looking at a few objects from everyday life, such as pens, books, smartphones, computers, etc.\nVery different objects!\nObjects can have many different shapes and characteristics, but you can classify different versions of the same object into a category or group. That's why it's easy to recognize a chair in a store, for example, although its appearance (shape, color, etc.) can vary greatly from one model to another.\nIt is by observing the common points between different objects that you are able, mentally, to classify the objects in the same group or category!\nFor example, there are different types of books, but they all have a title, an author, a back cover, etc. All books share different attributes that let you classify them in a well-identified category: books.\nClasses: Object Models\nIn programming, this concept of a group or category of objects is called a class. A class can be considered as the construction diagram for an object that will define the characteristics of all objects of this type and their features. From this class, you will be able to create different models of an object.\nLet's take a concrete example with a Car class. The plan of a car can be defined by:\nits characteristics, called attributes: it must have four wheels, a color, a shape, an engine power, etc.\nits functionalities, called methods: it can drive, brake, etc.\nSo, from this plan, you can create different car models:\nAn ordinary family car, green, medium power (110 hp)\nA sports car, red, relatively powerful (180 hp)\nA small blue city car, not very powerful (90 hp)\netc.\nAnd no matter what the car model, they are all capable of driving or braking, but not with the same performance!\nIn summary, a class is the outline of an object, defining its attributes and methods. From the same class, you can therefore create several objects of the same type, but with different attributes—these are called class instances.\nFocus on Methods\nAs we said before, in Python, everything is an object. This means that, without knowing it, since the beginning of this course, you have been manipulating objects! Consider the following lines of code to illustrate this:\nvar1 = 14\nvar2 = 1031\nHere, you have declared two variables named  var1  and  var2  containing the values 14 and 1,031. In reality, you have created two instances of the int class, two objects each with a single attribute: its value. The same is true for floats or strings: every time you create a variable of one of these types, you are actually creating objects in Python with the value you assign to them as an attribute.\nUp until now, we have talked about attributes, so now it is time to see what methods are. A class method is a function that is only available for the instances of this class. If, for example, we consider the Car class presented above having a drive() method, and a Plane class having a fly() method, you will agree quite logically that a plane can’t drive, and a car can’t fly. The same goes for our various objects!\nThe use of a method is always done via the   variableName.method()  notation. For example, strings have a method called   lower()  which will transform all the text contained in an object into lower case. Here's how to use it:\nThe string method: lower\nIn the same way as with functions, class methods can take parameters.\nString Methods\nDuring the various data analyses that you will have to perform, you will inevitably be confronted with textual variables at some point. You have already seen how to change your string to lowercase, but you may also need to replace some specific words, format the text in a certain way, etc.\nPython has implemented many methods to allow us to do all this. Here are the most common ones:\nupper() :  returns the whole text in upper case.\ncapitalize() :  returns the whole text in lowercase with the first letter capitalized.\nreplace(old, new) :  this method takes two arguments: old and new, both of which are strings.  The method returns the original string with all occurrences of old replaced with new. \nfind(string)  returns either the index of the first occurrence of the string passed in the  argument, or -1 if it does not find it.\nHere are some examples of how these methods are used:\nString Methods\nAs you can see here, especially with the lines concerning the  a  variable, the methods seen above do not modify the initial object! They only return the result of the method applied to the object. You will regularly have to reassign this result to the initial variable, when you want to modify it directly.\nTry it for Yourself\nManipulate objects yourself in the following exercise.\nYou can find the solution here.\nLet's Recap\nA class is a construction plan for an object.\nA variable is an instance of a class, or an object.\nAn object is defined by its attributes.\nAll instances of a class have access to the same methods via the.  (dot) notation.\nA method, like a function, generally does not modify the initial object.\nIn the next part, we will see in more detail how to organize your code via different structures and complex objects."
                    }
                ]
            },
            {
                "part_title": "Organize Objects and Manage Program Flow  Within a Project",
                "chapters": [
                    {
                        "chapter_title": "Create Collections to Store Your Objects",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979496-create-collections-to-store-your-objects",
                        "chapter_content": "Create Collections to Store Your Objects\nImagine again that you work in a bank. What you saw in part two was fine for treating each customer individually, but in reality, there's more than just one customer to analyze.\nIf you want to analyze several customers at once, you can imagine that you need a variable for each customer. For the names, this could look like this:\ncustomerName1 = 'Marion Weaver'\ncustomerName2 = 'Alberto Mendoza'\ncustomerName3 = 'Katharine Tyler'\ncustomerName4 = 'Isaac Steele'\n# etc.\nIf you have 10 customers to analyze, wouldn't it be easier to store them all in a single variable that would contain all the information?\nYou're in luck! Python offers a structure, a class capable of storing multiple pieces of information as a kind of array. This structure is called a list. Let's see how to use it.\nDeclare a List to Store Your Items\nLists are objects that can contain a collection of objects of any type.  We can have a list containing several integers (1, 2, 50, 2,000 or more, it doesn't matter), a list containing floats, a list containing strings, or even a list mixing objects of different types.\nLists are ordered objects, i.e., each item of the list is associated with a number corresponding to its order in the list. This number is called an index and it starts at 0 (not 1!). The first item is therefore associated with index 0, the second with index 1, etc.\nDeclaring a list is quite similar to the declaration of any variable seen so far: via a name to which we associate a list of items to be stored in this name.\nFor example, here is the list containing the names of four customers:\ncustomerName = ['Marion Weaver', 'Alberto Mendoza', 'Katharine Tyler', 'Isaac·Steele']\nNow that your list is created, you can perform two basic operations:\nAccess a value at a given index\nChange the value at a given index\nIn both cases, the code consists of the name of the variable followed by  [, the value of the index and  ].\nFor example, if you made a mistake on the name of the first customer and you want to correct their name:\n# assign the value 'Marianne Weaver' to the first name in our list\n# it is index 0, because indices start at 0 in python!\ncustomerName[0] = 'Marianne Weaver'\nTo print it, you can write the following line:\nprint(customerName[0])\nPython also lets you use negative indices to access or modify an item. The index -1 corresponds to the last item of the list, -2 to the second last, and so on. You can also access an index range by using the  :  operator. For example, 1:3 will let you access items two to four.\n# print the last item\nprint(customerName[-1])\n# access the second item to the 3rd\nprint(customerName[1:3])\n# access all items from the beginning to the second\nprint(customerName[:2])\nHere you have manipulated lists of strings, but you can do the same thing with the amount in each individual's account:\namountAccount = [10000, 150, 300, 1800.74]\nYou will probably have noticed, but in our last list, the first three items are integers, while the last one is a decimal. As we said before, you can store several different objects in the same list.\nFor example, the following list is completely valid:\nstrangeList = [4, 10.2, 'Marion Weaver', ['another list', 1]]\n# print the 4th item of the list\nprint(strangeList[3])\nTry it for Yourself\nWork with lists yourself in the following exercise.\nYou can find the solution here.\nWhat should we do now if a new customer is added to our analysis? When I try to do customerName[4] = '...', it returns an error!\nDon't panic! You can't access an index that doesn't already exist in a list in Python... however, lists have many methods that let you remedy this.\nList Methods\nNow consider that you want to list animals in order of cuteness (from cutest to \"least\" cute). We can easily start with a list of four animals: fox, koala, owl, and otter. These days, while browsing the internet, you will inevitably come across this image:\nThis one deserves a place at the top, right?\nAnd now you want to add the cat to the first position!\nThe good news for our little cat is that the lists are fully editable, whether it's the number of items, their order, etc. Thanks to the different list methods, we can:\nsearch for a specific item in the list.\nadd a new item at the end.\ninsert a new item at a specific index.\ndelete an item from the list.\nAdd Items to a List\nYou can create an empty list in Python and then add the items one by one via the append method:\nlist = []\nlist.append(7)\nlist.append(5)\nprint(list) # => [7, 5]\nThe first statement creates an empty list, very creatively named list.\nYou then add the integer 7 to the end of the list. So Python will add it to index 0.\nFinally, you add the integer 5, which will be stored at the next index, which is index 1.\nYou will notice that you did not need to write list = list.append(...). Unlike the string methods seen previously, this one does modify the original object.\nHere are some other methods that are essential to know about lists:\ninsert  to insert a new item at a specific position. For example,   list.insert(1, 12)  will insert the integer 12 at index 1, moving the old item 1 to index 2 and so on.\nextend :  similar to append, but with another list. This allows you to concatenate several lists together.\nremove : searches for the given item in the list and deletes the first occurrence. For example, if you want to delete 5 from your list, you can use :  list.remove(5) .\nindex : this method lets you find the index of the first occurrence of an item to be searched for in our list;\nKeyword  del  to delete an item according to its index.\nNow let's try out some of these methods:\nlist = []\nlist.append(7) # -> [7]\nlist.append(5) # -> [7, 5]\nlist.insert(1,12) # [7, 12, 5]\nlist[0] = 4 # -> [4, 12, 5]\nlist.remove(12) # [4, 5]\nlist.index(5) # prints 1\nlist.extend([1, 2, 3]) # [4, 5, 1, 2, 3]\ndel list[3] # [4, 5, 1, 3]\nLet's break down these few lines:\nThe first three lines correspond to what was seen before.\nYou then add 12 to index 1. The value that was in position 1 is moved to position 2.\nYou then replace the value at index 0 with 4.\nWith the  .remove()  method, you remove the integer 12 from our list.\nYou then ask for the index of the first item 5 in our list (here in second position, so return 1).\nYou add the list   [1, 2, 3]  after our initial list.\nAnd, finally, you delete the item located at position 4 in our list.\nIn the end, this leaves you with the final list:  [4, 5, 1, 3] .\nKeep Control of Your List\nThe   len()  function lets you retrieve the size of your list:\nlist = [1, 2, 3]\nlen(list) # will print 3\nThe   len  function is used a lot, especially when you need to scan the different items in a list with a loop, as you will see in the next chapter!\nTry it for Yourself\nTake a more in-depth approach to working with lists in the following exercise.\nThe solution is right here.\nUse Dictionaries\nNow, let's come back to our problem with the bank's customer names and associated accounts. With the above method, you would need two lists - a list of customer names and a list of account balances. Each time a new person is added to our data, their name and bank account balance would be added to the corresponding lists.\nDictionaries are another type of object, similar to lists, but which will let you do this with a single variable! Indeed, a dictionary is a list of items organized via a system of keys. With a real dictionary, you look up a word to access its definition. In programming, this word corresponds to the key and the definition to the value associated with it. This is called a key-value pair. So, we could have:\nMarion Weaver\nAlberto Mendoza\nKatharine Tyler\nIsaac Steele\n10000\n150\n300\n1800.74\nHere, the first row represents the keys and the second row represents the corresponding values.\nEach key in a dictionary must be unique. Strings are generally used to define keys, but this is not a requirement, per se.\nDeclare a Dictionary\nLists and dictionaries are declared in a similar way, except that a dictionary uses curly brackets instead of square brackets, and key-value pairs must be declared:\naccounts = {'Marion Weaver': 10000, 'Alberto Mendoza': 150, 'Katharine Tyler': 300, 'Isaac Steele': 1800.74}\nprint(accounts['Alberto Mendoza']) # -> 150\nThe last line will print the value associated with the key \"Alberto Mendoza\" which is 150.\nManipulate the Items of a Dictionary\nHere are the operations frequently carried out with dictionaries:\nAccess the value of an item\nAdd a new item (a new key-value pair)\nDelete an item via its key\nA value can be accessed or modified using the same notation as with lists. With dictionaries, unlike lists, this notation even lets you add items.\nLet's see this in action in the following example:\naccounts['Marion Weaver'] -= 2000 # I subtract 2000 from David's account\naccounts['Kristian Roach'] = 1000 # I add a new individual in my dictionary\nprint(accounts['Kristian Roach']) # I print the value of Kristian's account\nFinally, you can delete an item via the pop()  method by specifying the key of the item you want to delete.\naccounts.pop('Alberto Mendoza') # deletes Alberto Mendoza from our dictionary\nFinally, in the same way as with lists, you can use the   len()  function to see how your dictionary grows in size:\nlen(accounts) # -> 4\nUnderstand Immutable Tuples\nThe last type of collection we will look at are tuples. These are very similar to lists:\nThey are ordered objects, so we can access the different items stored in a tuple from their index.\nYou can store any kind of object in a tuple.\nThe main difference is that once a tuple has been declared, it cannot be modified. It is then said that it is immutable.\nWe can't modify a tuple? So what's the point of it?!\nThey might not seem to provide much benefit at first sight, but they can be used:\nwhen you want to make sure that data is not modified within a program.\nto return several values from a function. Indeed, we didn't address this point when we talked about functions, but it is possible to return several values... with a tuple!\nto declare several variables in one line.\nDeclare a Tuple\nTuples are declared in a very similar way to lists, except parentheses are used instead of square brackets:\nmy_tuple = (1, 2, 3, 'a', 'b')\nManipulate Tuples\nAs explained above, tuples are ordered objects, so we can use indices to select the items of a tuple:\nprint(my_tuple[1]) # -> 2\nprint(my_tuple[4]) # -> 'b'\nYou can also declare several variables at the same time from a tuple:\na, b = (1, 'apple')\nprint(a) # -> 1\nprint(b) # -> 'apple'\nHowever, you will get an error if you try to modify your tuple in any way, as you can see below.\nAttempt to modify a tuple—failed!\nLet's Recap\nIn this chapter, you have learned all the basics of using Python’s different built-in \"collection types\":\nLists: an ordered, editable collection where each item is associated with an index\nDictionaries: an unordered, editable collection where each item is associated with a key\nTuples: an ordered, non-mutable collection , where each item is associated with an index\nThe most common actions performed with lists and dictionaries are:\nAccess an item\nAdd an item\nDelete an item\nModify an item\nCount the number of items stored\nWe can perform these different actions via methods.\nThe type to use depends on the task at hand. As you progress in your career, you will be able to better identify the structure that is best suited to your situation!\nWe will now see how to organize our code via conditional structures."
                    },
                    {
                        "chapter_title": "Control Your Code With Conditional Structures",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979677-control-your-code-with-conditional-structures",
                        "chapter_content": "Control Your Code With Conditional Structures\nAs you work on more and more complex projects, writing a set of lines that run in sequence will not be enough! This is where conditional structures come into play.\nIn our very first chapters, you saw how to say \"Hello, world.\" Wouldn't it be better to modify this program slightly to be a little more specific and say hello to a particular person?\nPrint Information if Available\nWhen you start your program, you do not necessarily know the name of the user in advance. How about a program that can:\nsay hello to a particular user, if you know their name...\nif not, continue to say hello to everyone?\nHere is your first condition, which will let you build your first conditional structure.\nHow can you get a person's name in the first place?\nDo you remember functions? Yes, you worked it out, you can do this via a function: the  input  function. This will ask the notebook user (in other words... you!) to enter a string which will then be stored in a variable.\nLet's look at an example:\nInput function with Jupyter!\nYou have a space to answer the question and your answer will be stored as a string in the   username  variable.\nNow design the code that will let you say hello to your user:\nAsk the user their name and store their answer in a variable:   name .\nCheck that the  name  variable definitely contains a value (in case the user doesn't give an answer). The   len  function will help you to perform this task!\nIf this is the case, say Hello to your user with their name.\nOtherwise, keep saying Hello to the world. \nHere is the corresponding code:\nname = input( 'What is your name, dear stranger?')\nif len(name) > 0:\n    print(\"Hello\", name, \"!\")\nelse:\n    print(\"Hello, world!\")\nIt works well! Everything indented below the if is executed if the condition is true, otherwise the program runs everything indented below the else.\nAs you can see in the example above, the block construction using the:  operator and indentation are essential and omnipresent concepts in Python! Be very careful about the organization of your code at this level, to avoid some lines being run when they should not be, and vice versa.\nLet's take a closer look at how the if structure works in practice.\nUse Booleans: The No-Half-Measure Type\nIn Python, to validate a condition, you use a special type (or object ) called boolean. A Boolean variable can only contain two values: True or False. It's actually a pretty simple thing, but oh so useful!\nIn Python, the boolean can take the values True and False. Now see how to declare booleans in Python:\nthisCourseIsGreat = True\nitsAuthorIsVeryHumble = False\nEasy, right?\nTo get back to your if conditional structure, I think you'll understand, but it's absolutely necessary that what follows the if keyword results in a boolean. This can be done via:\na    True  or   False  value. For example,   if True : .\na boolean variable. For example,   if myVariable:  where   myVariable  is a boolean.\nan expression that results in a boolean value, as in the example above.\nFor example:\nweather = \"The weather is great!\"\nweather.startswith(\"The weather\") # -> True\nstartswith  is a method of the string class, which returns   True  when the string starts exactly with the string passed as a parameter;  False , if not. For example, you could use this expression to perform an action if a sentence begins with a particular word.\nTo produce Booleans, you can also use comparison operators.\nComparison Operators\nAs the name suggests, comparison operators are used to compare two values. There are six main ones:\n==  equal to (two values are exactly the same)\n!=  different from\n<  less than\n<=  less than or equal to\n>  greater than\n>=  greater than or equal to\nHere are some examples with numeric variables:\n2 == 2 # -> True\n2 == 3 # -> False\n4 != 4 # -> False\n4!= 5 # -> True\n1 < 2 # -> True\n1 < 1 # -> False\n1 <= 1 # -> True\n3 > 4 # -> False\n5 > 4 # -> True\n5 >= 4 # -> True\nThe result of these operations can be assigned to a variable:\nage=15\nif age>=21:\n    # Do something if age is greater than or equal to 21\nSometimes, you will need more elaborate conditions, where the condition will be the result of combining several expressions. This is where logical operators come in.\nLogical Operators\nThese operators will let you mix several Boolean values: specific Boolean values or expression results. There are three of them:\nand : the AND operator.\nThe final result is true only when all expressions/values are true. For example: the result of  expression1 and expression2  will be True only if   expression1  is true AND expression2  is also true.\nor : the OR operator.\nThe final result is true when at least one of the expressions/values is true. For example: the result of  expression1  or  expression2   will be at True if   expression1  is true OR expression2  is true.\nnot : the NOT operator.\nThis simply reverses the result of the given expression. For example, the result of   not(expression)  is true when   expression  is false.\nHere are some examples with the results shown as comments:\nTrue and True # True\nTrue and False # False\nFalse and False # False\nTrue or False # True\nTrue or True # True\nFalse or False # False\nnot(True) # False\nnot(False) # True\nYou can also mix more than two expressions/values:\nTrue and True and True # True\nTrue and True and False # False\nTrue or False or False # True\nFalse or False or False # False\nAs with numeric operations, logical operators respect the priorities of operations: the  not  operator is applied first, then the  and  operator, then the   or  operator. For example:\nFalse or True and True # True\nnot(False) and True or False # True\nYou can also use parentheses to change the order:\n(True and False) or True # True\nnot(True and False or not(True)) # True\nThe general form of a conditional if structure is   if condition:  where the condition can be either a boolean, or a variable of boolean type, or the result of an expression leading to a boolean result.\nThe  in  Operator\nAnother useful logical operator in Python is the   in  operator. This returns   True  when a value is found in a sequence (a string or a list);  False , if not.\nFor example:\nmyList = [4, 2, 3, 2, 10]\nmyStringList = [\"a\", \"b\", \"c\", \"d\"]\nmyString = \"The weather is really good today!\"\n4 in myList # True\n0 in myList # False\n0 in myStringList # False\n\"c\" in myStringList # True\n\"e\" in myStringList # False\n\"weather\" in myString # True\n\"really\" in myString # True\n\"rain?\" in myString # False\nIn your \"Hello, world!\" example, you have defined only one alternative. What if you have more than one alternative?\nManage a Chain of Conditions\nTo grant a loan, a bank relies (among other things) on the status of its users' accounts. For example, a naive decision rule might be:\nIf the customer has more than $10,000 in their account, they are automatically approved for their loan.\nIf they have between $100 and $10,000, we need to manually approve their application.\nOtherwise, the request is denied.\nWe could use two nested if statements, but Python can link several conditions thanks to the keyword   elif  (contraction of else and if). Here is the general form:\nif condition1:\n    # instructions\nelif condition2:\n    # instructions\nelse:\n    # instructions\nHere is the code corresponding to the example presented above:\naccount = input(\"What is your account balance?\")\naccount = int(account) # transform the answer into an integer\nif account >= 10000:\n    print(\"Loan granted!\")\nelif account >= 100 and account < 10000:\n    print(\"Loan in process of validation: under study\")\nelse:\n    print(\"Loan refused\")\nTry it for Yourself\nUse conditional structures in the following exercise.\nYou can find the solution right here.\nLet's Recap\nConditions let you execute a block of code when a Boolean, variable, or expression is true (True).\nExpressions use Boolean arithmetic, including logical operators and comparison operators.\nYou can apply several conditions with if/elif/else chains.\nIn the next chapter, you will see another way to control the code via loops."
                    },
                    {
                        "chapter_title": "Choose the Appropriate Loop",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979810-choose-the-appropriate-loop",
                        "chapter_content": "Choose the Appropriate Loop\nImagine that you have a block of code that you want to repeat several times in succession. You can of course store it in a function and call this function as many times as necessary. This would work, but it would be a bit like killing a fly with a bazooka: it works, but it is not necessarily the most optimal solution. Especially since, generally, we do not necessarily know in advance how many times we will need to repeat the said block of code.\nLoops solve this problem! In programming, a loop is a structure that lets you repeat one or more statements, without having to rewrite them each time. There are two types of loops (for and while), which will be explained shortly.\nLoop a Set Number of Times With the for Loop\nFor loops are used when you know in advance how many times an action will be repeated.\nHowever, unlike most other languages, in Python a for loop will necessarily iterate through a collection (list, dictionary, string, etc.).\nThe for Loop on a Collection\nThe conventional use of loops in Python is to directly use the different values of a collection. Here is an example with a list:\nScan a list via a loop\nThe printed result corresponds to each item in the list taken one by one. Let's take a detailed look at what has been achieved in the above code:\nYou have created a list:   myList, containing four items: 7, 2, 4, and 10.\nThe loop will store the first value of the list (in this case 7) in the   elt  variable.\nThen, the whole block of code associated with the for loop (defined via indentation... again!) is run with   elt  holding the first value. Here, this block just involves printing   elt.\nOnce this is done,   elt  will take the second value of the list (in this case 2) and the block of code is re-run.\nThe loop will continue until all the values in your list have been stored in the    elt  variable and the statements for the loop have been executed for each of them.\nHere is a diagram to understand the Python logic behind the loop:\nUnderstand the logic of the loop!\nYou can also iterate via a string! Remember that strings are also known as \"character strings\" because they represent a collection of characters, similar to a list.\nmyString = \"Items\"\nfor elt in myString:\n    print(elt)\nIn this case,   elt  will successively take each character of your string.\nThe for Loop via an Iterative Integer Value\nQuite often, you will find that you simply need to loop over a range of integer values, e.g. 0, 1, 2, 3….  This is the conventional loop you see most often in languages like Javascript or C++.  Because Python wants to loop over a collection, you need to create a collection containing your range of integer values.\nTo do this, you will use the   range(start, stop, step)  function, which will generate a collection of numbers according to three parameters:\nstart : the first number of the sequence.\nstop  corresponds to the last number of the sequence, non-inclusive. The function will generate numbers from   start  to   stop-1.\nstep :  the step between each generated number.\nNot all parameters are necessary. For example:\nfor i in range(0, 5, 1):\nfor i in range(0, 5, 1):\n    print(i) # -> print from 0 to 4 by steps of 1 (end - 1)\nfor i in range(0, 5):\n    print(i) # -> prints from 0 to 4 also (default step is 1)\nfor i in range(5):\n    print(i) # -> prints from 0 to 4 also (default start is 0)\nfor i in range(0, 5, 2):\n    print(i) # -> print 0, 2 then 4\nThe iterative variable can take any name. When iterating over an integer, we usually use values like   i ,   j , or k. Otherwise, it is better to use explicit names, as seen above ( elt being the abbreviation for item).\nThe for loop is perfectly suited when you have to perform an action a certain number of times known in advance or an action for each item of a collection. For all other cases, we can make a conditional loop: a loop that does not iterate through a collection, but according to a condition.\nLoop According to a Condition with the while Loop: \nThe conditional loop is the while loop in Python.\nAs its name implies, the while loop will run as long as a condition is met. It is a kind of combination of a for loop and an if structure. The number of repetitions is not defined in advance, but via a condition to be fulfilled, as with an if. This is called a conditional loop.\nThe syntax is as follows:\nwhile expressionLogic:\n    # block to execute\nIt can be interpreted as: as long as my logical expression is true, run the statement block.\nHere's how it works:\nThe program checks that   expressionLogic  is equal to   True.\nIf this is the case, the indented statements following the   :   are run. Once this is done, we return to step one.\nOtherwise, the program exits the loop without running the statements.\nTry the example below:\nnumberTrees = 0\nwhile numberTrees < 10:\n    numberTrees += 1\n    print(\"I planted\", numberTrees, \"trees\")\nprint(\"I have a nice forest!\")\nThis will produce the following result:\nPlant a forest!\nWith each iteration, the   numberTrees  is incremented by one. When the variable reaches the value 10, the expression   numberTrees < 10  is no longer true! At this point, the loop ends and continues running the rest of the program in order. In this specific case, it prints: \"I have a cool forest!\"\n❗️ It is essential to keep in mind that a misused while loop can crash your program! ☠️ While the condition is still true, the program remains stuck in a loop. If the condition never becomes false, the program will never exit the loop.  We are in what is called, in programming, an infinite loop.\nHere is an example not to be reproduced at home (this one was made by a professional...):\ntheSunIsShining = True\nwhile theSunIsShining:\n    print(\"Stay awake... forever!\")\n    # the theSunIsShining never changes, so the condition is always true\n# so we never reach this line\nprint(\"Time to go to sleep!\")\nThis is a common mistake and unfortunately it can happen very easily. So be careful!\nTry it for Yourself\nRun a few loops yourself in the next exercise.\nYou can find the solution here.\nSkip Some Statements Within Your Loop\nRegardless of the type of loop, there will be situations where you will want to skip some of the iterations within your loop, or even terminate the loop prematurely.\nFor example, you want to repeat something 10 times, but skip (at least partially) when the value is 2 or 5. In Python, to force the start of the next loop iteration, use the keyword continue:\nfor i in range(10):\n    # statements executed at each iteration\n    print(i)\n    if (i == 2) or (i == 5):\n        print(\"Special case\")\n        continue\n    # statements not executed if i == 2 or 5\n    print(\"i != 2 & i != 5\")\nYou can also decide to interrupt the loop, for example when looking for a particular item in a list. For this, you will use the   break  keyword.\nbasket = [\"apple\", \"orange\", \"banana\"]\nfor fruit in basket:\n    if fruit == \"orange\":\n        print(\"I have an orange!\")\n        break\nOnce the fruit has been found in your basket, you finish the loop.\nLet's Recap\nIn this chapter, you have discovered two types of loops:\nThe loop for repeating an action a certain number of times, or according to a sequence: the for loop.\nThe loop that allows you to repeat an action as long as a condition is true: the while loop.\nThere is a common mistake that you must not make with the while loop: the infinite loop!\nYou can choose to skip certain loop iterations via the continue keyword.\nThe cycles of the loop can be interrupted via the break command.\nNow that you have seen how to control your program flow, you can broaden your horizons with the discovery of modules and libraries!"
                    }
                ]
            },
            {
                "part_title": "Use Specialized Python Libraries",
                "chapters": [
                    {
                        "chapter_title": "Familiarize Yourself With Python Modules and Libraries",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7979957-familiarize-yourself-with-python-modules-and-libraries",
                        "chapter_content": "Familiarize Yourself With Python Modules and Libraries\nNow, suppose you need to calculate the square root of a number in one of your notebooks. There is no native square root function in Python. You could of course write it yourself, but hey, there's probably been a bunch of people who have asked themselves the same question. And guess what? One of them has already written the function and saved it in a module!\nA Module in Python\nA module is a Python file containing a set of predefined and operational functions, classes, and variables, which you can use as you wish in your code!\nFor example, if you are working on a problem involving geometry, you might need:\nclasses:\nSquare—defined by the length of its side\nTriangle—defined by the length of its three sides\nCircle—defined by its radius\nEtc.\nvariables:\nPi: constant necessary for calculating the area of a circle, equal to 3.1415...\nPhi: constant that represents the golden ratio, equal to 1.6180...\nfunctions:\nArea: takes as parameter a geometrical object (square, triangle, etc.) and calculates its area\nAngles: takes a triangle as a parameter, and calculates its internal angles\nEtc.\nYou can of course define all these things in your notebook, but that would only make it more cumbersome. The best is to store all this in an external Python file, which you will then import into your notebook: it's a module!\nYour geometry module\nHere is a simplified example of a geometry module:\n'''\nModule geometry.py\n'''\n# variables\npi = 3.14159265359\nphi = 1.6180\n# function that calculates the area\ndef area(obj):\n    if type(obj) == square:\n        return obj.a**2\n# definitions of some classes\nclass square(object):\n    def __init__(self,a):\n        self.a = a\nclass triangle(object):\n    def __init__(self,a,b,c):\n        self.a = a\n        self.b = b\n        self.c = c\nTo import a module, you will need the  import  keyword. Here is an example with our geometry module:\nimport geometry\nAfter doing this, you can use the different items defined in your module:\nsqua = geometry.square(4)\ntri = geometry.triangle(3, 6, 5)\nprint(geometry.pi) # -> 3.14159265359\ngeometry.area(squa) # -> 16\nAll items included in the geometry module can be used via the   moduleName.  notation, i.e.,  moduleName.function()  or   moduleName.variable. So, in the above example, we can use  geometry.area()  or  geometry.pi. If you don't want to rewrite geometry every time, you have two other options:\nEither give an alias to the name of your module, so you only have to write the alias:\nimport geometry as geo # we can now access geo.area() or geo.pi\nOr, import specific functions that you can then use as native Python functions/variables (without the  .  notation):\nfrom geometry import pi\nprint(pi) # -> 3.14159265359\nA particular case of this last method is to import in one line all the objects contained in a module via the  *  notation. However, this is not the recommended method, in order to avoid, for example, conflicts between several modules that might have identical function names.\nfrom geometry import *\nWhen a Module is Not Enough: Packages\nA package (sometimes called a library) is a collection, a set of Python modules. As you have seen above, a module is a Python file. A package is simply a folder containing several Python files (.py) and an additional file named   __init__.py. This differentiates a package from an ordinary folder containing only Python codes.\nFor example, you could have stored your geometry module in three different files instead of just one:\nOne for classes: classes.py\nOne for variables: variables.py\nOne for functions: functions.py\nIn this case, we would have the following file:\nOrganization of geometry package\nYou will need to use the . operator to access the module after importing the package:\nimport geometry # import all the geometry package\nprint(geometry.variables.pi) # -> 3.1415...\nsqua = geometry.classes.square(4)\ngeometry.functions.area(squa) # -> 16\nOr, you can also import only one module from the package:\nimport geometry.variables as var # import only what is defined in variables.py\nprint(var.pi) # -> 3.1415...\nPackages in Data Analysis\nPackages are ubiquitous in data analysis with Python. Indeed, many packages have been created specifically to address the issues that this subject involves. As you progress, you will be required to:\nmanipulate your data to facilitate analysis.\nmake various relevant graphs representing the behavior of your data.\nuse statistical methods.\nrun machine learning algorithms of varying complexity.\netc.\nAnd to achieve all this, you will need to master the various objects and functions from the corresponding packages.\nIf you want to know more about the packages that let you do these different tasks, you can take the OpenClassrooms course Use Python Libraries for Data Science, which goes into more detail about the packages that are most used in data analysis.\nTo come back to your initial problem (having a square root function), there is for example the numpy package which offers the necessary function—and many other things!\nimport numpy as np\nnp.sqrt(16) # -> 4.0\nIn order to solidify the concept of packages, we will look at a concrete example of the use of therandom package in the next chapter.\nLet's Recap\nIn this chapter, together we have seen the basics of using modules and packages:\nA module is a file containing Python code (.py extension) that can define functions, classes, and/or variables.\nYou can import any Python module via the import keyword.\nTo use a function class or a variable within a module, you must use the  .  operator.\nA package is a set of several Python modules.\nThere are many packages specifically created for data analysis.\nNow that you know what a module is in Python, follow me to the next chapter to discover how the random module works."
                    },
                    {
                        "chapter_title": "Manipulate Random Numbers With the Random Module",
                        "chapter_url": "https://openclassrooms.com/en/courses/2304731-learn-python-basics-for-data-analysis/7980005-manipulate-random-numbers-with-the-random-module",
                        "chapter_content": "Manipulate Random Numbers With the Random Module\nThe ability to generate random numbers is extremely useful for all sorts of programming tasks, from a simple simulation of a dice roll to selecting data for data analysis activities. In Python, the random module contains several functions for generating random numbers or sequences of numbers.\nIf you are interested in the subject, the different functions of the random module use a very powerful and popular pseudo-random number generator, called the Mersenne Twister.\nGenerate Random Numbers\nFirst, import your random module. The name of the package in Python is... random:\nimport random\nThe basic function for generating random numbers is called... random() as well (how original!). It will generate a random float between 0 and 1 (not including 0 or 1). Let's try a simple example by displaying three random numbers:\nOf course, if you run the same code at home, you will get different results (that’s the nature of randomness)!\nBut only having a number between 0 and 1 is a bit limited... isn't it?\nAbsolutely! But the people who created the random package fortunately thought of everything. There are other functions that let you generate a random number in a given range:\nuniform(a, b) : will generate a random float between   a  and   b .\nrandint(a, b) : as its name suggests, this one is similar to   uniform  except that the random number generated is an integer this time!\nYou can use one or the other according to your needs!\nGenerate a Random Number According to a Given Distribution\nThe random module can also generate a random number according to a distribution. One of the best known is the Gaussian (or normal) distribution. If you don't know it already, let me introduce you to it!\nThe normal law is one of the most suitable probability laws to model natural phenomena resulting from several random events. These are all phenomena where the majority of individuals are around an average, with decreasing proportions below and above this average. Here is a very telling example, with the distribution of the population by IQ:\nProportion of the population by IQ—Alessio Damato, Mikhail Ryazanov\nThe random module lets you generate random numbers according to this law: i.e., you are much more likely to have values close to the average (with the example above, between 85 and 115) than extreme values (close to 70 or 130). The corresponding function is called   gauss(mean, standard_deviation) .\nHere is an example with a distribution centered at 0 and with a standard deviation of 1 (which is a “conventional” normal distribution):\nWe can see here, with 10 values, that the majority of the values are close to 0.\nChoose Randomly From a List: Subsampling\nAs you already know, to select an item in a list, you have to select it via its index. If you want to select an item randomly from a list, a somewhat naive solution might be to draw the index randomly, and then use the random index to select the item. The random module goes a step further by offering a function that lets you make the selection directly from the list: the    choice  function.\nThe evolution of this is the  choices  function, now making it possible to select a sample from the initial list, with replacement:\nNote how, in the second line, we get “two” returned twice, because the first “two” was effectively put back into the list once it was initially drawn.\nThis is called subsampling. The corresponding function, for a sample without replacement, is sample :\nIn data analysis, this concept of subsampling is essential, as it can select a sample from an initial population. In statistics, a sample is a set of individuals representative of a population. The use of a subsample is generally a solution to a practical constraint (lack of time, space, financial cost, etc.) that does not allow an exhaustive study of the entire population.\nFurther Reading\nThe random module offers more functions than those presented in this course, even though you have seen the ones that are most commonly used in practice. If you want to go further, you can consult the official documentation of the random module, which lists all the possibilities offered by it.\nYou should also know that the numpy package, which we briefly mentioned in the previous chapter, also includes the random module. There, you will find all the functions seen above. All functions are accessible via the line (for example):\nimport numpy.random as random\nLet’s Recap\nYou have seen the main features available through the random module. You can now:\ngenerate a random number, integer, or decimalin a given range.\ngenerate a random number according to a given distribution.\nrandomly select one or more items from a list, with or without replacement."
                    }
                ]
            }
        ]
    },
    {
        "course_title": "Build Your First Web Pages With HTML and CSS",
        "course_url": "https://openclassrooms.com/en/courses/5265446-build-your-first-web-pages-with-html-and-css",
        "parts": [
            {
                "part_title": "Introduction to HTML and CSS",
                "chapters": [
                    {
                        "chapter_title": "Write your first lines of HTML and CSS",
                        "chapter_url": "https://openclassrooms.com/en/courses/5265446-build-your-first-web-pages-with-html-and-css/5265453-write-your-first-lines-of-html-and-css",
                        "chapter_content": "Write your first lines of HTML and CSS\nWelcome! You're here because you want to build websites. That's a pretty good plan these days. Who doesn't want to make groovy, cool sites like the ones we all know and use to stay in touch with our friends, to foster social good, and more?\nYou might've already heard \"Oh, just start with HTML!\" Just start with CSS!\" when you ask about how to begin learning programming.\nThat advice is pretty solid.\nHTML (Hypertext Markup Language) is the tool which will allow you to build webpages and CSS (Cascading Style Sheets) is what you use to make them look the way you want them to.\nWe'll explore both languages and write your first snippets of each. Let's start with something a little more familiar: web pages!\nPages\nWeb pages are like regular pages, but online. Thanks, Captain Obvious! This is a useful comparison to explore, though. Consider a newspaper page. On it, you have headings, sections, articles, images, and layouts which organize content that's styled to look a certain way.\nBack in the old days, it was someone's responsibility to physically arrange elements on a newspaper printing press in order to tell a story. They would set attention-grabbing headlines, for example, that were complemented by content in paragraphs. They would lay out the different sections and articles on a page according to the hierarchy of the content and the story they wanted to tell via these elements.\nThen, depending on the newspaper, the exact type-setting would have a certain font and characteristic style. The aesthetic appearance of the page is different from the content itself.\nThis separation is exactly the same for web pages. You have:\ncontent\nits appearance\nHTML is the language that handles the first concern: creating structured content to tell a story.\nCSS covers the second concern: customizing the appearance of that content to visually bring it to life.\nWriting the two languages separately means that it's much easier just to focus on content or appearance without worrying about both at the same time. For example, let's say OpenClassrooms were to entirely overhaul its brand colors and design. This would only require adapting the CSS, meaning the appearance of the site. The content (like courses) could be left alone, unchanged.\nLet's look at some examples, starting with some simple text without HTML to structure it or CSS to decorate it:\nPure text\nPretty unreadable, right?  Now, let's look at the same text, but structured with HTML:\nText structured with HTML\nIt's plain, or even ugly to some, but much more readable.  Now, what does the above text structured with HTML look like when we add some decoration via CSS?\nText with HTML & CSS\nOoh la la! This last page looks the best! Its content is structured with headings and paragraphs (via HTML), and it's decorated nicely (via CSS).\nPractice!\nWe haven't studied the syntax of HTML and CSS yet. In fact, we've barely touched them at all! Nonetheless, we're going to dive right into writing our first lines of these two languages so that you can immediately understand the relationship between content (HTML) and its appearance (CSS). You're going to write your first snippets of HTML and CSS. You don't need to understand why the code looks the way it does; we'll get to that in the next chapter! The point of this exercise is for you to get your first taste of adding content (HTML) and changing its appearance (CSS). \nIf you've never written code before, don't worry! The practice environment that you'll see in this chapter is completely safe. 😅 You can type anything you want, and you won't cause problems on a real website. Enjoy the \"Ah-hah!\" moment of seeing coded content come to life. It's an important step for new web developers and will definitely motivate you for what comes next.\nHead to this CodePen Exercise and follow the instructions below.\nIn the HTML editor, in line 6, remove the text <!--REMOVE ME -->.\nPaste or type this in the now-empty line 6, replacing my name with your name instead: <h1>Hello! My name is Emily. Here is some HTML!</h1>\nNow, head to the CSS code. It's time to change the content's appearance. Beneath the dark text editing area, click the blue \"Refresh\" button. This will load your changes, and you'll see your new content in the browser!\nRemove the placeholder text (/* REMOVE ME */) in the CSS code.\nPaste or type the following, exactly as it is:\nh1 {\n    color: blue;\n    background-color: yellow;\n    font-family: sans-serif;\n}\nAllow the page to refresh, and observe your content's new appearance in the browser!\nLet's recap!\nYou should have a large heading with blue text, a yellow background, and a sans serif font. If this isn't the case, make sure you followed all the steps above and loaded your changes with the green \"Run Code\" button."
                    },
                    {
                        "chapter_title": "Create content using HTML",
                        "chapter_url": "https://openclassrooms.com/en/courses/5265446-build-your-first-web-pages-with-html-and-css/5265716-create-content-using-html",
                        "chapter_content": "Create content using HTML\nIn this chapter, we'll go over HTML in more detail and learn how to tell a story with your code.\nTell a story with your content\nWhen you're writing an article, press release, or other written document for work or school, you should make sure to structure your content in a way that makes sense. The same is true when you write HTML on the web.\nCompare these two articles on a camping website. Which of these do you prefer?\nUnstructured and structured text\nThe content on the right tells a better story! It shows hierarchy of information, and the content is more understandable thanks to this structure. This, on the web, is accomplished by writing good HTML.\nYou're not the only one \"seeing\" your content though. Browsers and search engines also see your web page, but they don't have eyes. They do, however, understand HTML.\nSearch engines like Google read your website's code in order to figure out what the page is about. That way, when users search for something, your website will appropriately be shown in the list of results. Your browser also reads your code in order to show elements in a certain way. If you don't write clear HTML, your site won't be readable because browsers won't know what to do with it. End of story.\nBasic HTML syntax\nHTML uses tags in order to describe each piece of content on a webpage. It's up to you, as a developer, to choose the right tags!\nCheck out this line of HTML below from the camping example (and don't let the weird characters like <> freak you out):\n<h1>Camping essentials</h1>\nLet us dissect this friendly code snippet.\n<h1>\nIn HTML, this first set of characters is called an opening tag. Whatever comes between the < and > signs indicates which type of element you're creating. h1 is a heading, for example, and it's the most powerful (biggest) heading possible. \nAn \"element\" is anything on a web page. It could be a paragraph, an image, a heading, etc.\nCamping essentials\nAfter an opening tag, you'll often have the text content that will be shown. In this heading, the text \"Camping essentials\" is shown as a heading as specified in the opening tag.\n</h1>\nThis final set of characters in HTML is a closing tag. It indicates that you've concluded this particular element. It should be identical to the opening tag except with a forward slash after the <.\nIf this seems complex, let's think about how you format elements in a word processing document. Often, you highlight them from start to finish, and then turn them into a heading (if that's what you want).\nThe same is true in HTML. You must turn your content into a heading. By writing opening and closing <h1> tags around content, you indicate that the content inside should be turned into a big heading.\nTherefore, when you write this HTML code for an example article on camping supplies:\n<h1>Camping essentials</h1>\nYou end up with this result:\nAlmost every HTML element you write will follow this pattern (opening tag, content, closing tag). Let's look at one more example to drill home that point.\n<p>Packing the right gear is crucial for having a good time on your next camping trip. Make sure you bring the right stuff using our checklist.</p>\nYou end up with this result:\n<p> is the opening tag in the above example (therefore, </p> is the closing tag). The content in the middle becomes a paragraph because \"p\" stands for \"paragraph\".\nHTML element names are often abbreviations of the kind of content they represent. You'll see many of these elements in parts 2 and 3 of the course.\nPractice!\nIn this next code exercise, you'll place basic HTML tags around pre-written content. This is what developers do when they receive the text for a new web page from, say, the marketing team or a copywriter. It's your turn to try!\nHead to this CodePen exercise. The content is totally unformatted (look below the text editor to see the result). The first line doesn't show as a heading, text isn't shown as paragraphs...yikes. Turn each piece of text into the proper HTML element by enclosing it in opening and closing tags. Make sure to load your changes each time by clicking the blue \"Refresh\" button. They won't show otherwise! Follow the instructions bellow:\nTurn the text \"Neighborhood girl rescues cat from tree\" into a large heading by enclosing it in the correct opening and closing tags.  \nHint:\nOpening tag: <h1> \nClosing tag: </h1> \nTurn the text group that starts with \"Jill Jackson, a resident of Oak Lane...\" into a paragraph by enclosing it in the correct opening and closing tags. \nHint:\nOpening tag: <p>\nClosing tag: </p> \nTurn the text group that starts with \"Whispers has a reputation...\" into a paragraph by enclosing it in the correct opening and closing tags. \nHint:\nOpening tag: <p> \nClosing tag: </p> \nTurn the text group that starts with \"When asked to comment...\" into a paragraph by enclosing it in the correct opening and closing tags. \nHint:\nOpening tag: <p> \nClosing tag: </p>"
                    },
                    {
                        "chapter_title": "Decorate your content with CSS",
                        "chapter_url": "https://openclassrooms.com/en/courses/5265446-build-your-first-web-pages-with-html-and-css/5265796-decorate-your-content-with-css",
                        "chapter_content": "Decorate your content with CSS\nIn the last chapter, you got your first taste of creating content on the web via HTML. You also changed its appearance to have a yellow background, blue text, and a particular font via CSS. After spending the last chapter looking at HTML, it's now time to take a quick look at CSS. CSS lets you control the appearance of your web content.\nWhat is CSS? What does it look like? These are the fundamentals we'll explore in this chapter!\nCascading style sheets\nCSS stands for Cascading Style Sheets. That's a complicated way of saying that CSS allows you to set styles.\nStyles are like decoration. Imagine saying \"I want my website background color to be yellow, the text up top to be black, the text in the bottom section of the page to be white, the images to have a bit of space around them, and the whole thing to appear differently on mobile.\" All of those colors and spacing and placement is style. You just write it in code, not in English!\nYou also use CSS to create a layout for your site, such as placing a certain section on the left of the page, determining the size of the navigation bar that appears at the top of your website, or making multiple sections appear side-by-side in one row.\nCSS controls the way different pieces of content are arranged on websites. For example, the fact that there is a column with articles on the left of the New York Times and newspaper sections arranged in a horizontal bar (World, U.S., etc.) is not a coincidence! Developers created this layout with CSS:\nNew York Times layout\nWhile CSS is very powerful, it depends on HTML. Consider decorating a house. First, you select your element, like the bedroom walls or living room floor. Then, you specify how it should look: the dining room walls should be red, or the living room floor should be carpeted. If an interior designer asked how you want to decorate the dining room, and you just said \"Red,\" they wouldn't know what you're talking about. You must say you're talking about the walls first.\nThe same is true for HTML and CSS. In some quick examples, let's see what that looks like.\nThis chapter is just a quick overview of how CSS works. We'll dive much deeper into it later in the course.\nCSS applied to HTML\nThere are two steps while using CSS to make your HTML look awesome:\nIdentify and select the relevant HTML element (ex. paragraph, header, etc).\nAdd some styles (specify how it should look).\nLet's say we want the text of our paragraph to be blue:\np {\n    color: blue;\n    font-family: Arial;\n}\nThis may seem completely foreign, especially the curly brackets, but take another look. Can you recognize some elements?\np: refers to the paragraph tag in HTML, which is <p>.\ncolor: blue: color is a CSS property. Here, we've made the text color blue.\nfont-family: this is also a CSS property to set the font of your text. In the example above, it is set to Arial. We will get into the intricacies of choosing fonts later in the course.\n{ }: curly brackets open and close a set of style rules in CSS\nHere are the before and after results of the above code snippet:\nBefore (no CSS, just the default HTML appearance)\nAfter (CSS applied to HTML)\nLet's recap!\nBy understanding how HTML and CSS play together, you already have a huge leg up for learning the intricacies of each language. Remember:\nWrite your content in HTML.\nDecorate you content with CSS.\nIn the next part, we'll cover the largest building blocks in HTML to structure an entire web page!"
                    }
                ]
            },
            {
                "part_title": "Create HTML text elements",
                "chapters": [
                    {
                        "chapter_title": "Create headings for strong page structure",
                        "chapter_url": "https://openclassrooms.com/en/courses/5265446-build-your-first-web-pages-with-html-and-css/5266966-create-headings-for-strong-page-structure",
                        "chapter_content": "Create headings for strong page structure\nWelcome to part 2 of this course, where you'll learn a broad overview of common HTML elements that you'll find useful when building your projects.\nAs you use these elements, bear in mind what we discussed in part 1: the HTML you write should suit the story you want to tell with your content. This means choosing elements with purpose. Let's see what your options are.\nTextual structuring\nWhen you read a book, you may notice that the book's title is often the largest heading in the whole thing. There are usually headings at the beginning of each chapter, but they're smaller. Lastly, the book's actual text (\"Once upon a time, there was...\") is never in the form of an enormous, 300-page long heading; that would be impractical and impossible to read! It's often in a smaller font size.\nAdding structure to a text creates a hierarchy for the content in an immediate, easy-to-understand way. Apply the same thinking to the text in your web pages by using <h> elements and <p> elements. You've already seen both in this course!\nIn this chapter, we'll only look at headings. In the next, we'll put together headings and paragraphs to make a nice text flow.\nHeading elements\nCreate headings in HTML by using tags that include a lowercase \"h\" and a number from 1-6. The numbers 1-6 let you control the default size of your heading and therefore the importance it has in your page structure.\nWhat do each of these tags — <h1>, <h2>, <h3>, <h4>, <h5>, <h6> — actually look like on a web page?\n<h1>I'm an h1 heading!</h1>\n<h2>I'm an h2 heading!</h2>\n<h3>I'm an h3 heading!</h3>\n<h4>I'm an h4 heading!</h4>\n<h5>I'm an h5 heading!</h5>\n<h6>I'm an h6 heading!</h6>\nScreenshot 2018-03-19 08.21.58.png\n As the number from 1-6 increases, the heading becomes smaller!\nIf you're wondering why you need so many headings, remember that <h1> headings often reserved for page titles, smaller headings are to delineate articles  and sub-sections, etc. You should only use one <h1> heading per page so as not to confuse your reader or browsers/search engines about the page's primary content, but you're free to use the others as much as you like.\nMake sure your opening and closing tags match as you make headings. If they don't, your headings won't work. For example,  <h1>Big heading</h3>  won't result in a heading because h1 in the opening tag and h3 in the closing tag don't match.\nYou won't have only heading elements in your web page. You'll also have normal-sized text underneath the headings. Let's see that in the next chapter!"
                    }
                ]
            },
            {
                "part_title": "Structure an entire page",
                "chapters": []
            },
            {
                "part_title": "Spice up your content with CSS",
                "chapters": []
            }
        ]
    }
]